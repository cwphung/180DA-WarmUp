1.1 An image showing the raspi is working can be seen in raspi3.jpg
1.2 The serial monitor printouts can be found in raspi3_mqtt.png
1.3 The baseline scripts were used without improvements.
2.1 The wifi connection can be found in raspi3_internet.jpg.
3.1 Using the RasPi, running MQTT is the same as Lab 2 because the RasPi has its own OS and is capable of running python. A screenshot of the gyro and accel data from an Adruino Nano 33 IOT can be found in gyro.png.
3.2 The lag is directly correlated with the rate of messages being sent. If we send the constant flow of Arduino sensor data, we observe a considerable amount of lag. Limiting the sensor inputs to 1 measurement a second eliminates the lag entirely. If we were to only send a message when needed, this would also be a valid method of reducing the number of communications and thereby reducing lag. If we cannot reduce the frequency of messages, another method of reducing lag would be to reduce the amount of data being sent in each message.
4.1 The accelerometer and gyroscope serial output can be seen in gyro.png. Z is the up and down direction, and we see a +1 acceleration in the Z direction when the Arduino is idle. A screenshot is shown in idle.png
4.2 As shown in idle.png, the idle position is characterized by 0 accleration in the X and Y direction, +1 acceleration in the Z direction, and the values do not drift. The gyro data still fluctuates, so it is not a great idea to classify the idle state using gyro data. Thus we can classify the idle state by ensuring the magnitude of acceleration in both X and Y is under 0.02, and the acceleration in Z is between 1.03 and 0.97. Using this classification, we get a 0% error rate, in which all idle states are classified as idle, and all non-idle states are classified as non-idle.
4.3 We can classify forward push as an X acceleration less than -0.2 and Z acceleration between 0.7 and 1.3, and an upward lift as a Z acceleration less than 0.7. We also increase the threshold on the idle state to 0.1 rather than 0.02, since the IMU is more likely to be in motion. These classifications were made using a decision tree with X, Y, Z accelerations as parameters.
4.4 We cannot use the same features since this motion is nontrivial. Furthermore, the circular motion can be done in any direction which further complicates the decision boundary. In the previous tasks, a simple decision tree was used that took the parameters of a single instance in time. However, for a circular movement which takes longer to complete, we must add a history of accelerometer and gyroscope data to determine our decision boundary. Using a simple decision tree, we were unable to correctly classify the circular motion. One approach to classify such a complex motion would require a greater sized dataseet and utilize a neural network with at least 1 hidden layer. An easier action that we could classify is another trivial action such as pushing backwards, pushing down, pushing left or right, or rotating in a certain direction.